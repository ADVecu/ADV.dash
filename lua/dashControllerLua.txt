setTickRate(300)
timeout = 3000

gearSensor = Sensor.new("DetectedGear")
gearSensor : setTimeout(timeout)

rpmSensor = Sensor.new("Rpm")
rpmSensor : setTimeout(timeout)

swIN = 3
swOUT = 0

drlIN = 0
lowBeanOUT = 2
drlOUT = 1
fogOUT = 3
luxINA = 0

dashOUT = 4
oilswINA = 1
sidestINA = 2
coolantIN = 1
dirIzqIN = 5
dirDerIN = 7
highBeanIN = 3

dashPayLoad = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
dashPayLoad2 = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }

drlTimer = Timer.new()
drlTimer : reset()

commTimer = Timer.new()
commTimer : reset()

lowBeanOnTimer = Timer.new()
lowBeanOnTimer : reset()

lowBeanOffTimer = Timer.new()
lowBeanOffTimer : reset()

commDelay = 20
drlDelay = 5

lowBeanVon = findSetting(lowBeanVon, 0.5)
lowBeanVoff = findSetting(lowBeanVoff, 2)
lowBeanDelayOn = findSetting(lowBeanDelayOn, 2)
lowBeanDelayOff = findSetting(lowBeanDelayOff, 5)
lowBeanON = false

startPwm(swOUT, 100, 0)
startPwm(drlOUT, 100, 0)
startPwm(lowBeanOUT, 100, 0)
startPwm(fogOUT, 100, 0)
startPwm(dashOUT, 100, 0)

hexstr = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "A", "B", "C", "D", "E", "F" }

function toHexString(num)
	if num == 0 then
		return '0'
	end

	local result = ""
	while num > 0 do
		local n = num % 16
		result = hexstr[n + 1] ..result
		num = math.floor(num / 16)
	end
	return result
end

function arrayToString(arr)
	local str = ""
	local index = 1
	while arr[index] ~= nil do
		str = str.." "..toHexString(arr[index])
		index = index + 1
	end
	return str
end

function getTwoBytesLSB(data, offset, factor)
	return (data[offset + 2] * 256 + data[offset + 1]) * factor
end

function setTwoBytesLsb(data, offset, value)
	value = math.floor(value)
	data[offset + 2] = value >> 8
	data[offset + 1] = value & 0xff
end

function onGEARFRAME(bus, id, dlc, data)
	gearValue = data[1]
	gearSensor : set(gearValue)
end

function onRPMFRAME(bus, id, dlc, data)
	local rpms = getTwoBytesLSB(data, 0, 1)
	rpmSensor : set(rpms)
end

canRxAdd(1, 0x1FF, onGEARFRAME)
canRxAdd(1, 0x201, onRPMFRAME)

function onTick()

-- SW MANAGER ///////////////////////////////////////////////

	if (getAuxDigital(swIN) == false) then
		setPwmDuty(swOUT, 1)
		setPwmDuty(drlOUT, 1)
		commTimer : reset()
		drlTimer : reset()
	else
		setPwmDuty(swOUT, 0)
		if (drlTimer : getElapsedSeconds() > drlDelay) then
			setPwmDuty(drlOUT, 0)
		end
	end

-- /////////////////////////////////////////////////////////

-- LOWBEAN MANAGER //////////////////////////////////////////

	if(rpmSensor > 1000) and (getAuxAnalog(luxINA) > lowBeanVon) and (not lowBeanON) then
		if (lowBeanOnTimer : getElapsedSeconds() > lowBeanDelayOn) then
			setPwmDuty(lowBeanOUT, 1)
			lowBeanON = true
		end
	else
		lowBeanOnTimer : reset()
	end

	if(getAuxAnalog(luxINA) < lowBeanVoff) and (lowBeanON) then
		if(lowBeanOffTimer : getElapsedSeconds() > lowBeanDelayOff) then
			setPwmDuty(lowBeanOUT, 0)
			lowBeanON = false
		end
	else
		lowBeanOffTimer : reset()
	end

	if (rpmSensor < 1000) and (lowBeanON) then
		setPwmDuty(lowBeanOUT, 0)
		lowBeanON = false
	end

-- /////////////////////////////////////////////////////////

-- DASH INFO ///////////////////////////////////////////////

	ambTemp = getSensor("AmbientTemperature")
	fuelLevel = getSensor("FuelLevel")
	oilPress = getSensor("OilPressure")
	oilTemp = getSensor("OilTemperature")

	setTwoBytesLsb(dashPayLoad, 0, oilPress)
	dashPayLoad[3] = fuelLevel
	dashPayLoad[4] = ambTemp
	dashPayLoad[5] = oilTemp

	if (getAuxDigital(coolantIN) == false) then dashPayLoad2[1] = 1 else dashPayLoad2[1] = 0
	if (getAuxDigital(highBeanIN) == false) then dashPayLoad2[2] = 1 else dashPayLoad2[2] = 0
	if (getAuxDigital(dirIzqIN) == false) then dashPayLoad2[3] = 1 else dashPayLoad2[3] = 0
	if (getAuxDigital(dirDerIN) == false) then dashPayLoad2[4] = 1 else dashPayLoad2[4] = 0
	
	txCan(1, 0x20E, 0, dashPayLoad)
	txCan(1, 0x20F, 0, dashPayLoad2)

-- /////////////////////////////////////////////////////////

-- SLEEP MANAGER //////////////////////////////////////////

	if getOutput("isUsbConnected") == 1 then
		commTimer : reset()
	end
	if (commTimer : getElapsedSeconds() > commDelay) and (getAuxDigital(swIN) == true) then
		mcu_standby()
	end

-- /////////////////////////////////////////////////////////
end