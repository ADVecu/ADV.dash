  // Wait for message to be received
  twai_message_t message;
  if (twai_receive(&message, pdMS_TO_TICKS(10000)) == ESP_OK)
  {
    printf("Message received\n");
  }
  else
  {
    printf("Failed to receive message\n");
    return;
  }

  // Process received message
  if (message.extd)
  {
    printf("Message is in Extended Format\n");
  }
  else
  {
    printf("Message is in Standard Format\n");
  }
  printf("ID is %d\n", message.identifier);
  if (!(message.rtr))
  {
    for (int i = 0; i < message.data_length_code; i++)
    {
      printf("Data byte %d = %d\n", i, message.data[i]);
    }
  }

  // twai_message_t message;
  String data;
  String identifier;
  /*if (twai_receive(&message, 0) == ESP_OK) {
    Serial.print("0x");
    Serial.print(message.identifier, HEX);
    Serial.print("\t");
    Serial.print(message.extd);
    Serial.print("\t");
    Serial.print(message.rtr);
    Serial.print("\t");
    Serial.print(message.data_length_code);

    for(int i=0;i<message.data_length_code;i++) {
      Serial.print("\t0x");
      if (message.data[i]<=0x0F) {
        Serial.print(0);
      }
      Serial.print(message.data[i], HEX);
    }
    Serial.println();
  }*/

  if (testTimer4.delayOn(initScreen, 1000))
  {
    _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_OVER_RIGHT, 100, 0, ui_MainScreen_screen_init);

    if (lv_scr_act() == ui_WelcomeScreen)
    {
      initScreen = false;
      _ui_screen_delete(&ui_WelcomeScreen);
    }
  }

  if (lv_scr_act() == ui_MainScreen && true)
  {
    lv_bar_set_value(ui_RpmsBar, random(8, 15), LV_ANIM_OFF);
    lv_label_set_text_fmt(ui_RpmsValue, "%d", random(800, 1500));

    if (lv_bar_get_value(ui_RpmsBar) >= 50 && entry)
    {
      lv_obj_set_style_bg_color(ui_RpmsBar, lv_color_hex(0xFF0000), LV_PART_INDICATOR | LV_STATE_DEFAULT);
      entry = false;
    }

    if (lv_bar_get_value(ui_RpmsBar) >= 100)
    {
      lv_obj_set_style_bg_color(ui_RpmsBar, lv_color_hex(0xFFFFFF), LV_PART_INDICATOR | LV_STATE_DEFAULT);
      entry = true;
      lv_bar_set_value(ui_RpmsBar, 0, LV_ANIM_OFF);
    }

    lv_arc_set_value(ui_Arc1, random(45, 48));
    lv_label_set_text_fmt(ui_ArcValue1, "%d", random(45, 48));

    lv_arc_set_value(ui_Arc2, random(10, 15));
    lv_label_set_text_fmt(ui_ArcValue2, "%d", random(10, 15));
    lv_arc_set_value(ui_Arc4, random(50, 60));
    lv_label_set_text_fmt(ui_ArcValue4, "%d", random(50, 60));

    lv_arc_set_value(ui_MainArc, random(30, 90));
    lv_label_set_text_fmt(ui_MainArcValue, "%d", random(30, 90));

    lv_label_set_text_fmt(ui_PanelValue1, "%d", random(100));

    lv_label_set_text_fmt(ui_PanelValue2, "%d", random(100));
    lv_label_set_text_fmt(ui_PanelValue4, "%d", random(100));
    lv_label_set_text_fmt(ui_PanelValue5, "%d", random(100));

    lv_label_set_text_fmt(ui_SpeedValue, "%d", random(80, 85));

    lv_bar_set_value(ui_TpsBar, random(50, 60), LV_ANIM_OFF);

    if (testTimer.cycleTrigger(500))
    {

      lv_label_set_text_fmt(ui_PanelValue6, "%d", random(90, 98));

      lv_bar_set_value(ui_Bar2, random(50, 52), LV_ANIM_OFF);
      lv_label_set_text_fmt(ui_BarValue2, "%d", random(100));

      lv_label_set_text_fmt(ui_GearValue, "%d", random(7));
    }

    if (testTimer2.cycleTrigger(1000))
    {

      lv_bar_set_value(ui_Bar1, random(80, 82), LV_ANIM_OFF);
      lv_label_set_text_fmt(ui_BarValue1, "%d", random(80, 82));

      lv_bar_set_value(ui_Bar3, random(40, 50), LV_ANIM_OFF);
      lv_label_set_text_fmt(ui_BarValue2, "%d", random(40, 50));

      lv_bar_set_value(ui_Bar4, random(70, 75), LV_ANIM_OFF);
      lv_label_set_text_fmt(ui_BarValue4, "%d", random(70, 75));

      lv_arc_set_value(ui_Arc3, random(95, 105));
      lv_label_set_text_fmt(ui_ArcValue3, "%d", random(95, 105));

      lv_label_set_text_fmt(ui_PanelValue3, "%d", random(85, 87));
    }
  }

  if (lv_scr_act() == ui_Screen2 && true)
  {
    /* if(twai_receive(&message, 0)  ==  ESP_OK){
       lv_label_set_text_fmt(ui_mID, "ID: 0x%08X", message.identifier);
       lv_label_set_text_fmt(ui_mData, "Data: 0x%02X", message.data);
       }*/
  }



board_build.arduino.memory_type
-DBOARD_HAS_PSRAM 






#include "Adafruit_NeoPixel.h"
#include "Arduino.h"
#include "pcb_definitions.h"
#include "led_control.h"

Adafruit_NeoPixel strip(LEDS_NUM, LEDS_PIN, NEO_GRB + NEO_KHZ800);

void led_control::init_leds()
{
    strip.begin();
    strip.show(); // Initialize all pixels to 'off'
    strip.setBrightness(10);

    xTaskCreatePinnedToCore(this->ledsWelcomeAnimation, "leds_Welcome", 10000, NULL, 1, NULL, APP_CPU_NUM);
}

void led_control::ledsWelcomeAnimation(void *pvParameters)
{
    while (1)
    {
        int firstPixelHue = 0; // First pixel starts at red (hue 0)
        for (int a = 0; a < 10; a++)
        { // Repeat 30 times...
            for (int b = 0; b < 3; b++)
            {                  //  'b' counts from 0 to 2...
                strip.clear(); //   Set all pixels in RAM to 0 (off)
                // 'c' counts up from 'b' to end of strip in increments of 3...
                for (int c = b; c < strip.numPixels(); c += 3)
                {
                    // hue of pixel 'c' is offset by an amount to make one full
                    // revolution of the color wheel (range 65536) along the length
                    // of the strip (strip.numPixels() steps):
                    int hue = firstPixelHue + c * 65536L / strip.numPixels();
                    uint32_t color = strip.gamma32(strip.ColorHSV(hue)); // hue -> RGB
                    strip.setPixelColor(c, color);                       // Set pixel 'c' to value 'color'
                }
                strip.show();                // Update strip with new contents
                delay(50);                 // Pause for a moment
                firstPixelHue += 65536 / 90; // One cycle of color wheel over 90 frames
            }
        }

        strip.clear();
        strip.show();
        vTaskDelete(NULL);
    }
}


https://github.com/adafruit/Adafruit_NeoPixel.git

#define NUM_DMA_BUFFERS 10
#include "FastLED.h"
#include "Arduino.h"
#include "pcb_definitions.h"
#include "led_control.h"
#include "../canBus/can_bus.h"

CRGB strip[LEDS_NUM];

TaskHandle_t ledWelcomeAnimTask;

bool initAnimationComplete = false;

void led_control::init_leds()
{

    FastLED.addLeds<WS2812B, LEDS_PIN, GRB>(strip, LEDS_NUM);
    FastLED.setBrightness(100);
    FastLED.show();

    xTaskCreatePinnedToCore(this->ledsWelcomeAnimation, "leds_Welcome", 10000, NULL, 1, &ledWelcomeAnimTask, APP_CPU_NUM);
    xTaskCreatePinnedToCore(ledControlTask, "ledControlTask", 10000, NULL, 4, NULL, 0);
}

void led_control::ledsWelcomeAnimation(void *pvParameters)
{
    while (1)
    {
        static uint8_t hue = 0;

        // First slide the led in one direction
        for (int i = 0; i < LEDS_NUM; i++)
        {
            // Set the i'th led to red
            strip[i] = CHSV(hue += 5, 255, 255);

            // Show the leds
            FastLED.show();
            // now that we've shown the leds, reset the i'th led to black
            // strip[i] = CRGB::Black;
            for (int i = 0; i < LEDS_NUM; i++)
            {
                strip[i].nscale8(250);
            }
            // Wait a little bit before we loop around and do it again
            delay(50);
        }

        delay(500);

        for (int i = (LEDS_NUM)-1; i >= 0; i--)
        {
            // Set the i'th led to red
            strip[i] = CHSV(hue += 5, 255, 255);
            // Show the leds
            FastLED.show();
            // now that we've shown the leds, reset the i'th led to black
            strip[i] = CRGB::Black;
            for (int i = 0; i < LEDS_NUM; i++)
            {
                strip[i].nscale8(250);
            }
            // Wait a little bit before we loop around and do it again
            delay(25);
        }

        FastLED.clear();
        FastLED.show();
        initAnimationComplete = true;
        vTaskSuspend(NULL);
    }
}

void led_control::triggerWelcomeAnimation()
{
    initAnimationComplete = false;
    vTaskResume(ledWelcomeAnimTask);
}

void led_control::setRmpsLeds(int rpms, int minRpms, int maxRpms)
{
    int ledsOn = map(rpms, minRpms, maxRpms, LEDS_RPMS_START, LEDS_RPMS_END);

    for (int i = LEDS_RPMS_START; i < LEDS_RPMS_END; i++)
    {
        strip[i] = CRGB::Black;
    }

    if (rpms < maxRpms)
    {

        for (int i = LEDS_RPMS_START; i < ledsOn; i++)
        {
            if (i >= LEDS_RPMS_LOW && i <= LEDS_RPMS_MID)
            {
                strip[i] = CRGB::Green;
            }
            else if (i >= LEDS_RPMS_MID && i <= LEDS_RPMS_MAX)
            {
                strip[i] = CRGB::Red;
            }
            else
            {
                strip[i] = CRGB::Blue;
            }
        }
        FastLED.show();
    }
    else
    {
        EVERY_N_MILLISECONDS(10)
        {
            static boolean ps0; // stores the pixel state
            ps0 = !ps0;         // toggle on/off state
            if (ps0 == 1)
            {
                for (int i = LEDS_RPMS_START; i < LEDS_RPMS_END; i++)
                {
                    strip[i] = CRGB::Red;
                }
            }
            else
            {
                for (int i = LEDS_RPMS_START; i < LEDS_RPMS_END; i++)
                {
                    strip[i] = CRGB::Black;
                }
            }

            FastLED.show();
        } // reset
    }
}

/*
void led_control::setIndicatorLeds(ledState state, ledPosition position, ledColor color)
{

    if (state == LED_ON)
    {
        strip[position] = color;
        FastLED.show();
    }
    else if (state == LED_OFF)
    {
        strip[position] = CRGB::Black;
        FastLED.show();
    }
    else if (state == LED_BLINK)
    {
        EVERY_N_MILLISECONDS(250)
        {
            static boolean ps0; // stores the pixel state
            ps0 = !ps0;         // toggle on/off state
            if (ps0 == 1)
            {
                strip[position] = color;
            }
            else
            {
                strip[position] = CRGB::Black;
            }

            FastLED.show();
        } // reset
    }
}
*/

void ledControlTask(void *pvParameters)
{

    canbus_data_t canbus_data;
    int ledsOn = 0;

    while (1)
    {
        if (xQueueReceive(canbus_queue, &canbus_data, portMAX_DELAY) == pdTRUE  && initAnimationComplete)
        {
            ledsOn = map(canbus_data.rpms, 3000, 6000, LEDS_RPMS_START, LEDS_RPMS_END);

            for (int i = LEDS_RPMS_START; i < LEDS_RPMS_END; i++)
            {
                strip[i] = CRGB::Black;
            }

            if (canbus_data.rpms < 6000)
            {

                for (int i = LEDS_RPMS_START; i < ledsOn; i++)
                {
                    if (i >= LEDS_RPMS_LOW && i <= LEDS_RPMS_MID)
                    {
                        strip[i] = CRGB::Green;
                    }
                    else if (i >= LEDS_RPMS_MID && i <= LEDS_RPMS_MAX)
                    {
                        strip[i] = CRGB::Red;
                    }
                    else
                    {
                        strip[i] = CRGB::Blue;
                    }
                }
                FastLED.show();
            }
            else
            {
                EVERY_N_MILLISECONDS(100)
                {
                    static boolean ps0; // stores the pixel state
                    ps0 = !ps0;         // toggle on/off state
                    if (ps0 == 1)
                    {
                        for (int i = LEDS_RPMS_START; i < LEDS_RPMS_END; i++)
                        {
                            strip[i] = CRGB::Red;
                        }
                    }
                    else
                    {
                        for (int i = LEDS_RPMS_START; i < LEDS_RPMS_END; i++)
                        {
                            strip[i] = CRGB::Black;
                        }
                    }

                    FastLED.show();
                } // reset
            }
           delay(10); 
        }
    }
}


https://github.com/FastLED/FastLED.git