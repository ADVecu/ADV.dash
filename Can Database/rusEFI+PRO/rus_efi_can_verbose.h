/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.5 Sat Jun 15 18:13:48 2024.
 */

#ifndef RUS_EFI_CAN_VERBOSE_H
#define RUS_EFI_CAN_VERBOSE_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define RUS_EFI_CAN_VERBOSE_BASE0_FRAME_ID (0x200u)
#define RUS_EFI_CAN_VERBOSE_BASE1_FRAME_ID (0x201u)
#define RUS_EFI_CAN_VERBOSE_BASE2_FRAME_ID (0x202u)
#define RUS_EFI_CAN_VERBOSE_BASE3_FRAME_ID (0x203u)
#define RUS_EFI_CAN_VERBOSE_BASE4_FRAME_ID (0x204u)
#define RUS_EFI_CAN_VERBOSE_BASE5_FRAME_ID (0x205u)
#define RUS_EFI_CAN_VERBOSE_BASE6_FRAME_ID (0x206u)
#define RUS_EFI_CAN_VERBOSE_BASE7_FRAME_ID (0x207u)
#define RUS_EFI_CAN_VERBOSE_BASE8_FRAME_ID (0x208u)
#define RUS_EFI_CAN_VERBOSE_PRO0_FRAME_ID (0x209u)
#define RUS_EFI_CAN_VERBOSE_PRO1_FRAME_ID (0x20au)

/* Frame lengths in bytes. */
#define RUS_EFI_CAN_VERBOSE_BASE0_LENGTH (8u)
#define RUS_EFI_CAN_VERBOSE_BASE1_LENGTH (8u)
#define RUS_EFI_CAN_VERBOSE_BASE2_LENGTH (8u)
#define RUS_EFI_CAN_VERBOSE_BASE3_LENGTH (8u)
#define RUS_EFI_CAN_VERBOSE_BASE4_LENGTH (8u)
#define RUS_EFI_CAN_VERBOSE_BASE5_LENGTH (8u)
#define RUS_EFI_CAN_VERBOSE_BASE6_LENGTH (8u)
#define RUS_EFI_CAN_VERBOSE_BASE7_LENGTH (8u)
#define RUS_EFI_CAN_VERBOSE_BASE8_LENGTH (8u)
#define RUS_EFI_CAN_VERBOSE_PRO0_LENGTH (8u)
#define RUS_EFI_CAN_VERBOSE_PRO1_LENGTH (8u)

/* Extended or standard frame types. */
#define RUS_EFI_CAN_VERBOSE_BASE0_IS_EXTENDED (0)
#define RUS_EFI_CAN_VERBOSE_BASE1_IS_EXTENDED (0)
#define RUS_EFI_CAN_VERBOSE_BASE2_IS_EXTENDED (0)
#define RUS_EFI_CAN_VERBOSE_BASE3_IS_EXTENDED (0)
#define RUS_EFI_CAN_VERBOSE_BASE4_IS_EXTENDED (0)
#define RUS_EFI_CAN_VERBOSE_BASE5_IS_EXTENDED (0)
#define RUS_EFI_CAN_VERBOSE_BASE6_IS_EXTENDED (0)
#define RUS_EFI_CAN_VERBOSE_BASE7_IS_EXTENDED (0)
#define RUS_EFI_CAN_VERBOSE_BASE8_IS_EXTENDED (0)
#define RUS_EFI_CAN_VERBOSE_PRO0_IS_EXTENDED (0)
#define RUS_EFI_CAN_VERBOSE_PRO1_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */


/* Frame Names. */
#define RUS_EFI_CAN_VERBOSE_BASE0_NAME "BASE0"
#define RUS_EFI_CAN_VERBOSE_BASE1_NAME "BASE1"
#define RUS_EFI_CAN_VERBOSE_BASE2_NAME "BASE2"
#define RUS_EFI_CAN_VERBOSE_BASE3_NAME "BASE3"
#define RUS_EFI_CAN_VERBOSE_BASE4_NAME "BASE4"
#define RUS_EFI_CAN_VERBOSE_BASE5_NAME "BASE5"
#define RUS_EFI_CAN_VERBOSE_BASE6_NAME "BASE6"
#define RUS_EFI_CAN_VERBOSE_BASE7_NAME "BASE7"
#define RUS_EFI_CAN_VERBOSE_BASE8_NAME "BASE8"
#define RUS_EFI_CAN_VERBOSE_PRO0_NAME "PRO0"
#define RUS_EFI_CAN_VERBOSE_PRO1_NAME "PRO1"

/* Signal Names. */
#define RUS_EFI_CAN_VERBOSE_BASE0_WARNING_COUNTER_NAME "WarningCounter"
#define RUS_EFI_CAN_VERBOSE_BASE0_LAST_ERROR_NAME "LastError"
#define RUS_EFI_CAN_VERBOSE_BASE0_REV_LIM_ACT_NAME "RevLimAct"
#define RUS_EFI_CAN_VERBOSE_BASE0_MAIN_RELAY_ACT_NAME "MainRelayAct"
#define RUS_EFI_CAN_VERBOSE_BASE0_FUEL_PUMP_ACT_NAME "FuelPumpAct"
#define RUS_EFI_CAN_VERBOSE_BASE0_CEL_ACT_NAME "CELAct"
#define RUS_EFI_CAN_VERBOSE_BASE0_EGO_HEAT_ACT_NAME "EGOHeatAct"
#define RUS_EFI_CAN_VERBOSE_BASE0_LAMBDA_PROTECT_ACT_NAME "LambdaProtectAct"
#define RUS_EFI_CAN_VERBOSE_BASE0_FAN_NAME "Fan"
#define RUS_EFI_CAN_VERBOSE_BASE0_FAN2_NAME "Fan2"
#define RUS_EFI_CAN_VERBOSE_BASE0_CURRENT_GEAR_NAME "CurrentGear"
#define RUS_EFI_CAN_VERBOSE_BASE0_DISTANCE_TRAVELED_NAME "DistanceTraveled"
#define RUS_EFI_CAN_VERBOSE_BASE1_RPM_NAME "RPM"
#define RUS_EFI_CAN_VERBOSE_BASE1_IGNITION_TIMING_NAME "IgnitionTiming"
#define RUS_EFI_CAN_VERBOSE_BASE1_INJ_DUTY_NAME "InjDuty"
#define RUS_EFI_CAN_VERBOSE_BASE1_IGN_DUTY_NAME "IgnDuty"
#define RUS_EFI_CAN_VERBOSE_BASE1_VEHICLE_SPEED_NAME "VehicleSpeed"
#define RUS_EFI_CAN_VERBOSE_BASE1_FLEX_PCT_NAME "FlexPct"
#define RUS_EFI_CAN_VERBOSE_BASE2_PPS_NAME "PPS"
#define RUS_EFI_CAN_VERBOSE_BASE2_TPS1_NAME "TPS1"
#define RUS_EFI_CAN_VERBOSE_BASE2_TPS2_NAME "TPS2"
#define RUS_EFI_CAN_VERBOSE_BASE2_WASTEGATE_NAME "Wastegate"
#define RUS_EFI_CAN_VERBOSE_BASE3_MAP_NAME "MAP"
#define RUS_EFI_CAN_VERBOSE_BASE3_COOLANT_TEMP_NAME "CoolantTemp"
#define RUS_EFI_CAN_VERBOSE_BASE3_INTAKE_TEMP_NAME "IntakeTemp"
#define RUS_EFI_CAN_VERBOSE_BASE3_AUX1_TEMP_NAME "AUX1Temp"
#define RUS_EFI_CAN_VERBOSE_BASE3_AUX2_TEMP_NAME "AUX2Temp"
#define RUS_EFI_CAN_VERBOSE_BASE3_MCU_TEMP_NAME "MCUTemp"
#define RUS_EFI_CAN_VERBOSE_BASE3_FUEL_LEVEL_NAME "FuelLevel"
#define RUS_EFI_CAN_VERBOSE_BASE4_OIL_PRESS_NAME "OilPress"
#define RUS_EFI_CAN_VERBOSE_BASE4_OIL_TEMPERATURE_NAME "OilTemperature"
#define RUS_EFI_CAN_VERBOSE_BASE4_FUEL_TEMPERATURE_NAME "FuelTemperature"
#define RUS_EFI_CAN_VERBOSE_BASE4_BATT_VOLT_NAME "BattVolt"
#define RUS_EFI_CAN_VERBOSE_BASE5_CYL_AM_NAME "CylAM"
#define RUS_EFI_CAN_VERBOSE_BASE5_EST_MAF_NAME "EstMAF"
#define RUS_EFI_CAN_VERBOSE_BASE5_INJ_PW_NAME "InjPW"
#define RUS_EFI_CAN_VERBOSE_BASE5_KNOCK_CT_NAME "KnockCt"
#define RUS_EFI_CAN_VERBOSE_BASE6_FUEL_USED_NAME "FuelUsed"
#define RUS_EFI_CAN_VERBOSE_BASE6_FUEL_FLOW_NAME "FuelFlow"
#define RUS_EFI_CAN_VERBOSE_BASE6_FUEL_TRIM1_NAME "FuelTrim1"
#define RUS_EFI_CAN_VERBOSE_BASE6_FUEL_TRIM2_NAME "FuelTrim2"
#define RUS_EFI_CAN_VERBOSE_BASE7_LAM1_NAME "Lam1"
#define RUS_EFI_CAN_VERBOSE_BASE7_LAM2_NAME "Lam2"
#define RUS_EFI_CAN_VERBOSE_BASE7_FP_LOW_NAME "FpLow"
#define RUS_EFI_CAN_VERBOSE_BASE7_FP_HIGH_NAME "FpHigh"
#define RUS_EFI_CAN_VERBOSE_BASE8_CAM1_I_NAME "Cam1I"
#define RUS_EFI_CAN_VERBOSE_BASE8_CAM1_ITAR_NAME "Cam1Itar"
#define RUS_EFI_CAN_VERBOSE_BASE8_CAM1_E_NAME "Cam1E"
#define RUS_EFI_CAN_VERBOSE_BASE8_CAM1_ETAR_NAME "Cam1Etar"
#define RUS_EFI_CAN_VERBOSE_BASE8_CAM2_I_NAME "Cam2I"
#define RUS_EFI_CAN_VERBOSE_BASE8_CAM2_ITAR_NAME "Cam2Itar"
#define RUS_EFI_CAN_VERBOSE_BASE8_CAM2_E_NAME "Cam2E"
#define RUS_EFI_CAN_VERBOSE_BASE8_CAM2_ETAR_NAME "Cam2Etar"
#define RUS_EFI_CAN_VERBOSE_PRO0_GEAR_SEN_NAME "GearSen"
#define RUS_EFI_CAN_VERBOSE_PRO0_SENSOR_ERROR_NAME "SensorError"
#define RUS_EFI_CAN_VERBOSE_PRO1_FW_PRESSURE_NAME "FWPressure"
#define RUS_EFI_CAN_VERBOSE_PRO1_RW_PRESSURE_NAME "RWPressure"
#define RUS_EFI_CAN_VERBOSE_PRO1_FW_TEMP_NAME "FWTemp"
#define RUS_EFI_CAN_VERBOSE_PRO1_RW_TEMP_NAME "RWTemp"
#define RUS_EFI_CAN_VERBOSE_PRO1_FW_BATT_V_NAME "FWBattV"
#define RUS_EFI_CAN_VERBOSE_PRO1_RW_BATT_V_NAME "RWBattV"

/**
 * Signals in message BASE0.
 *
 * All signal values are as on the CAN bus.
 */
struct rus_efi_can_verbose_base0_t {
    /**
     * Total warnings since ECU start time
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t warning_counter;

    /**
     * Last error code
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t last_error;

    /**
     * RPM Limiter Active
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t rev_lim_act;

    /**
     * Main Relay Active
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t main_relay_act;

    /**
     * Fuel Pump Output Active
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t fuel_pump_act;

    /**
     * Check Engine Light Active
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cel_act;

    /**
     * EGO Heater Commanded On
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ego_heat_act;

    /**
     * Lambda protection active (fault detected)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lambda_protect_act;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan2;

    /**
     * Current detected gear. 0 means neutral, 1 means first, etc.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t current_gear;

    /**
     * Distance traveled since reset
     *
     * Range: 0..65535 (0..6553.5 km)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t distance_traveled;
};

/**
 * Signals in message BASE1.
 *
 * All signal values are as on the CAN bus.
 */
struct rus_efi_can_verbose_base1_t {
    /**
     * Current RPM
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t rpm;

    /**
     * Current Ignition Timing. Positive is advance.
     *
     * Range: -
     * Scale: 0.02
     * Offset: 0
     */
    int16_t ignition_timing;

    /**
     * Injection Duty
     *
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t inj_duty;

    /**
     * Ignition Duty
     *
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t ign_duty;

    /**
     * Current Vehicle Speed
     *
     * Range: 0..255 (0..255 kph)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_speed;

    /**
     * Ethanol percent
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t flex_pct;
};

/**
 * Signals in message BASE2.
 *
 * Throttle positions
 *
 * All signal values are as on the CAN bus.
 */
struct rus_efi_can_verbose_base2_t {
    /**
     * Current Accelerator Pedal Position
     *
     * Range: 0..10000 (0..100 %)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pps;

    /**
     * Throttle Body 1 Position
     *
     * Range: 0..10000 (0..100 %)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t tps1;

    /**
     * Throttle Body 2 Position
     *
     * Range: 0..10000 (0..100 %)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t tps2;

    /**
     * Wastegate actuator position
     *
     * Range: 0..10000 (0..100 %)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t wastegate;
};

/**
 * Signals in message BASE3.
 *
 * All signal values are as on the CAN bus.
 */
struct rus_efi_can_verbose_base3_t {
    /**
     * Current MAP Reading
     *
     * Range: -
     * Scale: 0.03333333
     * Offset: 0
     */
    uint16_t map;

    /**
     * Current Coolant Temperature Reading
     *
     * Range: 0..240 (-40..200 deg C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t coolant_temp;

    /**
     * Current Intake Air Temperature
     *
     * Range: 0..240 (-40..200 deg C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t intake_temp;

    /**
     * Current Aux1 Temperature
     *
     * Range: 0..240 (-40..200 deg C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t aux1_temp;

    /**
     * Current Aux2 Temperature
     *
     * Range: 0..240 (-40..200 deg C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t aux2_temp;

    /**
     * Current MCU Temperature
     *
     * Range: 0..140 (-40..100 deg C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t mcu_temp;

    /**
     * Current Fuel Level
     *
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t fuel_level;
};

/**
 * Signals in message BASE4.
 *
 * All signal values are as on the CAN bus.
 */
struct rus_efi_can_verbose_base4_t {
    /**
     * Current Oil Pressure Reading
     *
     * Range: -
     * Scale: 0.03333333
     * Offset: 0
     */
    uint16_t oil_press;

    /**
     * Range: 0..255 (-40..215 deg C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t oil_temperature;

    /**
     * Range: 0..255 (-40..215 deg C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t fuel_temperature;

    /**
     * Current Battery Voltage Reading
     *
     * Range: 0..25000 (0..25 mV)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t batt_volt;
};

/**
 * Signals in message BASE5.
 *
 * All signal values are as on the CAN bus.
 */
struct rus_efi_can_verbose_base5_t {
    /**
     * Current Estmated Cylinder Airmass
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t cyl_am;

    /**
     * Currrent Estimated Total Airflow
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t est_maf;

    /**
     * Current Commanded Injector Pulsewidth
     *
     * Range: -
     * Scale: 0.003333333
     * Offset: 0
     */
    uint16_t inj_pw;

    /**
     * Knock detection counter
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t knock_ct;
};

/**
 * Signals in message BASE6.
 *
 * All signal values are as on the CAN bus.
 */
struct rus_efi_can_verbose_base6_t {
    /**
     * Total fuel consumed
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t fuel_used;

    /**
     * Fuel flow rate
     *
     * Range: 0..65400 (0..327 g/s)
     * Scale: 0.005
     * Offset: 0
     */
    uint16_t fuel_flow;

    /**
     * Fuel trim bank 1
     *
     * Range: -5000..5000 (-50..50 %)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t fuel_trim1;

    /**
     * Fuel trim bank 2
     *
     * Range: -5000..5000 (-50..50 %)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t fuel_trim2;
};

/**
 * Signals in message BASE7.
 *
 * Fueling
 *
 * All signal values are as on the CAN bus.
 */
struct rus_efi_can_verbose_base7_t {
    /**
     * Lambda sensor 1
     *
     * Range: 0..20000 (0..2 lambda)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t lam1;

    /**
     * Lambda sensor 2
     *
     * Range: 0..20000 (0..2 lambda)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t lam2;

    /**
     * Fuel pressure - low sensor
     *
     * Range: -
     * Scale: 0.03333333
     * Offset: 0
     */
    uint16_t fp_low;

    /**
     * Fuel pressure - high (GDI) sensor
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t fp_high;
};

/**
 * Signals in message BASE8.
 *
 * Cams
 *
 * All signal values are as on the CAN bus.
 */
struct rus_efi_can_verbose_base8_t {
    /**
     * Cam bank 1 intake actual
     *
     * Range: -100..100 (-100..100 deg)
     * Scale: 1
     * Offset: 0
     */
    int8_t cam1_i;

    /**
     * Cam bank 1 intake target
     *
     * Range: -100..100 (-100..100 deg)
     * Scale: 1
     * Offset: 0
     */
    int8_t cam1_itar;

    /**
     * Cam bank 1 exhaust actual
     *
     * Range: -100..100 (-100..100 deg)
     * Scale: 1
     * Offset: 0
     */
    int8_t cam1_e;

    /**
     * Cam bank 1 exhaust target
     *
     * Range: -100..100 (-100..100 deg)
     * Scale: 1
     * Offset: 0
     */
    int8_t cam1_etar;

    /**
     * Cam bank 2 intake actual
     *
     * Range: -100..100 (-100..100 deg)
     * Scale: 1
     * Offset: 0
     */
    int8_t cam2_i;

    /**
     * Cam bank 2 intake target
     *
     * Range: -100..100 (-100..100 deg)
     * Scale: 1
     * Offset: 0
     */
    int8_t cam2_itar;

    /**
     * Cam bank 2 exhaust actual
     *
     * Range: -100..100 (-100..100 deg)
     * Scale: 1
     * Offset: 0
     */
    int8_t cam2_e;

    /**
     * Cam bank 2 exhaust target
     *
     * Range: -100..100 (-100..100 deg)
     * Scale: 1
     * Offset: 0
     */
    int8_t cam2_etar;
};

/**
 * Signals in message PRO0.
 *
 * Gear Sensor
 *
 * All signal values are as on the CAN bus.
 */
struct rus_efi_can_verbose_pro0_t {
    /**
     * Gear detected by the sensor, 0 means Neutral, 1 first gear, etc.
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gear_sen;

    /**
     * Error Boolean
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sensor_error;
};

/**
 * Signals in message PRO1.
 *
 * TPMS 2 Wheels
 *
 * All signal values are as on the CAN bus.
 */
struct rus_efi_can_verbose_pro1_t {
    /**
     * Front Wheel Pressure
     *
     * Range: 0..10000 (0..100 PSI)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t fw_pressure;

    /**
     * Rear Wheel Pressure
     *
     * Range: 0..10000 (0..100 PSI)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t rw_pressure;

    /**
     * Front Wheel Temperature
     *
     * Range: 0..100 (-30..70 deg C)
     * Scale: 1
     * Offset: -30
     */
    uint8_t fw_temp;

    /**
     * Rear Wheel Temperature
     *
     * Range: 0..100 (-30..70 deg C)
     * Scale: 1
     * Offset: -30
     */
    uint8_t rw_temp;

    /**
     * Front Wheel Battery Voltage
     *
     * Range: 0..40 (0..4 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t fw_batt_v;

    /**
     * Rear Wheel Battery Voltage
     *
     * Range: 0..40 (0..4 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t rw_batt_v;
};

/**
 * Pack message BASE0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int rus_efi_can_verbose_base0_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base0_t *src_p,
    size_t size);

/**
 * Unpack message BASE0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int rus_efi_can_verbose_base0_unpack(
    struct rus_efi_can_verbose_base0_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BASE0.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int rus_efi_can_verbose_base0_init(struct rus_efi_can_verbose_base0_t *msg_p);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base0_warning_counter_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base0_last_error_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base0_rev_lim_act_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base0_main_relay_act_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base0_fuel_pump_act_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base0_cel_act_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base0_ego_heat_act_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base0_lambda_protect_act_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base0_fan_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base0_fan2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base0_current_gear_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base0_distance_traveled_is_in_range(uint16_t value);

/**
 * Pack message BASE1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int rus_efi_can_verbose_base1_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base1_t *src_p,
    size_t size);

/**
 * Unpack message BASE1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int rus_efi_can_verbose_base1_unpack(
    struct rus_efi_can_verbose_base1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BASE1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int rus_efi_can_verbose_base1_init(struct rus_efi_can_verbose_base1_t *msg_p);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base1_rpm_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base1_ignition_timing_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base1_inj_duty_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base1_ign_duty_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base1_vehicle_speed_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base1_flex_pct_is_in_range(uint8_t value);

/**
 * Pack message BASE2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int rus_efi_can_verbose_base2_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base2_t *src_p,
    size_t size);

/**
 * Unpack message BASE2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int rus_efi_can_verbose_base2_unpack(
    struct rus_efi_can_verbose_base2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BASE2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int rus_efi_can_verbose_base2_init(struct rus_efi_can_verbose_base2_t *msg_p);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base2_pps_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base2_tps1_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base2_tps2_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base2_wastegate_is_in_range(int16_t value);

/**
 * Pack message BASE3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int rus_efi_can_verbose_base3_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base3_t *src_p,
    size_t size);

/**
 * Unpack message BASE3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int rus_efi_can_verbose_base3_unpack(
    struct rus_efi_can_verbose_base3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BASE3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int rus_efi_can_verbose_base3_init(struct rus_efi_can_verbose_base3_t *msg_p);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base3_map_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base3_coolant_temp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base3_intake_temp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base3_aux1_temp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base3_aux2_temp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base3_mcu_temp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base3_fuel_level_is_in_range(uint8_t value);

/**
 * Pack message BASE4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int rus_efi_can_verbose_base4_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base4_t *src_p,
    size_t size);

/**
 * Unpack message BASE4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int rus_efi_can_verbose_base4_unpack(
    struct rus_efi_can_verbose_base4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BASE4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int rus_efi_can_verbose_base4_init(struct rus_efi_can_verbose_base4_t *msg_p);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base4_oil_press_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base4_oil_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base4_fuel_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base4_batt_volt_is_in_range(uint16_t value);

/**
 * Pack message BASE5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int rus_efi_can_verbose_base5_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base5_t *src_p,
    size_t size);

/**
 * Unpack message BASE5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int rus_efi_can_verbose_base5_unpack(
    struct rus_efi_can_verbose_base5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BASE5.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int rus_efi_can_verbose_base5_init(struct rus_efi_can_verbose_base5_t *msg_p);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base5_cyl_am_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base5_est_maf_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base5_inj_pw_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base5_knock_ct_is_in_range(uint16_t value);

/**
 * Pack message BASE6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int rus_efi_can_verbose_base6_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base6_t *src_p,
    size_t size);

/**
 * Unpack message BASE6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int rus_efi_can_verbose_base6_unpack(
    struct rus_efi_can_verbose_base6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BASE6.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int rus_efi_can_verbose_base6_init(struct rus_efi_can_verbose_base6_t *msg_p);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base6_fuel_used_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base6_fuel_flow_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base6_fuel_trim1_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base6_fuel_trim2_is_in_range(uint16_t value);

/**
 * Pack message BASE7.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int rus_efi_can_verbose_base7_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base7_t *src_p,
    size_t size);

/**
 * Unpack message BASE7.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int rus_efi_can_verbose_base7_unpack(
    struct rus_efi_can_verbose_base7_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BASE7.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int rus_efi_can_verbose_base7_init(struct rus_efi_can_verbose_base7_t *msg_p);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base7_lam1_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base7_lam2_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base7_fp_low_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base7_fp_high_is_in_range(uint16_t value);

/**
 * Pack message BASE8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int rus_efi_can_verbose_base8_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base8_t *src_p,
    size_t size);

/**
 * Unpack message BASE8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int rus_efi_can_verbose_base8_unpack(
    struct rus_efi_can_verbose_base8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BASE8.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int rus_efi_can_verbose_base8_init(struct rus_efi_can_verbose_base8_t *msg_p);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base8_cam1_i_is_in_range(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base8_cam1_itar_is_in_range(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base8_cam1_e_is_in_range(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base8_cam1_etar_is_in_range(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base8_cam2_i_is_in_range(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base8_cam2_itar_is_in_range(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base8_cam2_e_is_in_range(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_base8_cam2_etar_is_in_range(int8_t value);

/**
 * Pack message PRO0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int rus_efi_can_verbose_pro0_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_pro0_t *src_p,
    size_t size);

/**
 * Unpack message PRO0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int rus_efi_can_verbose_pro0_unpack(
    struct rus_efi_can_verbose_pro0_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PRO0.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int rus_efi_can_verbose_pro0_init(struct rus_efi_can_verbose_pro0_t *msg_p);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_pro0_gear_sen_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_pro0_sensor_error_is_in_range(uint8_t value);

/**
 * Pack message PRO1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int rus_efi_can_verbose_pro1_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_pro1_t *src_p,
    size_t size);

/**
 * Unpack message PRO1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int rus_efi_can_verbose_pro1_unpack(
    struct rus_efi_can_verbose_pro1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PRO1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int rus_efi_can_verbose_pro1_init(struct rus_efi_can_verbose_pro1_t *msg_p);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_pro1_fw_pressure_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_pro1_rw_pressure_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_pro1_fw_temp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_pro1_rw_temp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_pro1_fw_batt_v_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool rus_efi_can_verbose_pro1_rw_batt_v_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
