/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.5 Sat Jun 15 18:13:48 2024.
 */

#include <string.h>

#include "rus_efi_can_verbose.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

int rus_efi_can_verbose_base0_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base0_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->warning_counter, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->warning_counter, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->last_error, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->last_error, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->rev_lim_act, 0u, 0x01u);
    dst_p[4] |= pack_left_shift_u8(src_p->main_relay_act, 1u, 0x02u);
    dst_p[4] |= pack_left_shift_u8(src_p->fuel_pump_act, 2u, 0x04u);
    dst_p[4] |= pack_left_shift_u8(src_p->cel_act, 3u, 0x08u);
    dst_p[4] |= pack_left_shift_u8(src_p->ego_heat_act, 4u, 0x10u);
    dst_p[4] |= pack_left_shift_u8(src_p->lambda_protect_act, 5u, 0x20u);
    dst_p[4] |= pack_left_shift_u8(src_p->fan, 6u, 0x40u);
    dst_p[4] |= pack_left_shift_u8(src_p->fan2, 7u, 0x80u);
    dst_p[5] |= pack_left_shift_u8(src_p->current_gear, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->distance_traveled, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->distance_traveled, 8u, 0xffu);

    return (8);
}

int rus_efi_can_verbose_base0_unpack(
    struct rus_efi_can_verbose_base0_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->warning_counter = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->warning_counter |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->last_error = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->last_error |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->rev_lim_act = unpack_right_shift_u8(src_p[4], 0u, 0x01u);
    dst_p->main_relay_act = unpack_right_shift_u8(src_p[4], 1u, 0x02u);
    dst_p->fuel_pump_act = unpack_right_shift_u8(src_p[4], 2u, 0x04u);
    dst_p->cel_act = unpack_right_shift_u8(src_p[4], 3u, 0x08u);
    dst_p->ego_heat_act = unpack_right_shift_u8(src_p[4], 4u, 0x10u);
    dst_p->lambda_protect_act = unpack_right_shift_u8(src_p[4], 5u, 0x20u);
    dst_p->fan = unpack_right_shift_u8(src_p[4], 6u, 0x40u);
    dst_p->fan2 = unpack_right_shift_u8(src_p[4], 7u, 0x80u);
    dst_p->current_gear = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->distance_traveled = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->distance_traveled |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int rus_efi_can_verbose_base0_init(struct rus_efi_can_verbose_base0_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct rus_efi_can_verbose_base0_t));

    return 0;
}

bool rus_efi_can_verbose_base0_warning_counter_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base0_last_error_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base0_rev_lim_act_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

bool rus_efi_can_verbose_base0_main_relay_act_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

bool rus_efi_can_verbose_base0_fuel_pump_act_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

bool rus_efi_can_verbose_base0_cel_act_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

bool rus_efi_can_verbose_base0_ego_heat_act_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

bool rus_efi_can_verbose_base0_lambda_protect_act_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

bool rus_efi_can_verbose_base0_fan_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

bool rus_efi_can_verbose_base0_fan2_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

bool rus_efi_can_verbose_base0_current_gear_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base0_distance_traveled_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int rus_efi_can_verbose_base1_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base1_t *src_p,
    size_t size)
{
    uint16_t ignition_timing;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->rpm, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->rpm, 8u, 0xffu);
    ignition_timing = (uint16_t)src_p->ignition_timing;
    dst_p[2] |= pack_left_shift_u16(ignition_timing, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(ignition_timing, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->inj_duty, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->ign_duty, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->vehicle_speed, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->flex_pct, 0u, 0xffu);

    return (8);
}

int rus_efi_can_verbose_base1_unpack(
    struct rus_efi_can_verbose_base1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t ignition_timing;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->rpm = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->rpm |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    ignition_timing = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    ignition_timing |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->ignition_timing = (int16_t)ignition_timing;
    dst_p->inj_duty = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->ign_duty = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->vehicle_speed = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->flex_pct = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int rus_efi_can_verbose_base1_init(struct rus_efi_can_verbose_base1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct rus_efi_can_verbose_base1_t));

    return 0;
}

bool rus_efi_can_verbose_base1_rpm_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base1_ignition_timing_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base1_inj_duty_is_in_range(uint8_t value)
{
    return (value <= 200u);
}

bool rus_efi_can_verbose_base1_ign_duty_is_in_range(uint8_t value)
{
    return (value <= 200u);
}

bool rus_efi_can_verbose_base1_vehicle_speed_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base1_flex_pct_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

int rus_efi_can_verbose_base2_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base2_t *src_p,
    size_t size)
{
    uint16_t pps;
    uint16_t tps1;
    uint16_t tps2;
    uint16_t wastegate;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    pps = (uint16_t)src_p->pps;
    dst_p[0] |= pack_left_shift_u16(pps, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(pps, 8u, 0xffu);
    tps1 = (uint16_t)src_p->tps1;
    dst_p[2] |= pack_left_shift_u16(tps1, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(tps1, 8u, 0xffu);
    tps2 = (uint16_t)src_p->tps2;
    dst_p[4] |= pack_left_shift_u16(tps2, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(tps2, 8u, 0xffu);
    wastegate = (uint16_t)src_p->wastegate;
    dst_p[6] |= pack_left_shift_u16(wastegate, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(wastegate, 8u, 0xffu);

    return (8);
}

int rus_efi_can_verbose_base2_unpack(
    struct rus_efi_can_verbose_base2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t pps;
    uint16_t tps1;
    uint16_t tps2;
    uint16_t wastegate;

    if (size < 8u) {
        return (-EINVAL);
    }

    pps = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    pps |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->pps = (int16_t)pps;
    tps1 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    tps1 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->tps1 = (int16_t)tps1;
    tps2 = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    tps2 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->tps2 = (int16_t)tps2;
    wastegate = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    wastegate |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->wastegate = (int16_t)wastegate;

    return (0);
}

int rus_efi_can_verbose_base2_init(struct rus_efi_can_verbose_base2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct rus_efi_can_verbose_base2_t));

    return 0;
}

bool rus_efi_can_verbose_base2_pps_is_in_range(int16_t value)
{
    return ((value >= 0) && (value <= 10000));
}

bool rus_efi_can_verbose_base2_tps1_is_in_range(int16_t value)
{
    return ((value >= 0) && (value <= 10000));
}

bool rus_efi_can_verbose_base2_tps2_is_in_range(int16_t value)
{
    return ((value >= 0) && (value <= 10000));
}

bool rus_efi_can_verbose_base2_wastegate_is_in_range(int16_t value)
{
    return ((value >= 0) && (value <= 10000));
}

int rus_efi_can_verbose_base3_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base3_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->map, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->map, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->coolant_temp, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->intake_temp, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->aux1_temp, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->aux2_temp, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->mcu_temp, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->fuel_level, 0u, 0xffu);

    return (8);
}

int rus_efi_can_verbose_base3_unpack(
    struct rus_efi_can_verbose_base3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->map = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->map |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->coolant_temp = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->intake_temp = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->aux1_temp = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->aux2_temp = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->mcu_temp = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->fuel_level = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int rus_efi_can_verbose_base3_init(struct rus_efi_can_verbose_base3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct rus_efi_can_verbose_base3_t));

    return 0;
}

bool rus_efi_can_verbose_base3_map_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base3_coolant_temp_is_in_range(uint8_t value)
{
    return (value <= 240u);
}

bool rus_efi_can_verbose_base3_intake_temp_is_in_range(uint8_t value)
{
    return (value <= 240u);
}

bool rus_efi_can_verbose_base3_aux1_temp_is_in_range(uint8_t value)
{
    return (value <= 240u);
}

bool rus_efi_can_verbose_base3_aux2_temp_is_in_range(uint8_t value)
{
    return (value <= 240u);
}

bool rus_efi_can_verbose_base3_mcu_temp_is_in_range(uint8_t value)
{
    return (value <= 140u);
}

bool rus_efi_can_verbose_base3_fuel_level_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int rus_efi_can_verbose_base4_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base4_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[2] |= pack_left_shift_u16(src_p->oil_press, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->oil_press, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->oil_temperature, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->fuel_temperature, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->batt_volt, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->batt_volt, 8u, 0xffu);

    return (8);
}

int rus_efi_can_verbose_base4_unpack(
    struct rus_efi_can_verbose_base4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->oil_press = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->oil_press |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->oil_temperature = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->fuel_temperature = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->batt_volt = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->batt_volt |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int rus_efi_can_verbose_base4_init(struct rus_efi_can_verbose_base4_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct rus_efi_can_verbose_base4_t));

    return 0;
}

bool rus_efi_can_verbose_base4_oil_press_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base4_oil_temperature_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base4_fuel_temperature_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base4_batt_volt_is_in_range(uint16_t value)
{
    return (value <= 25000u);
}

int rus_efi_can_verbose_base5_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base5_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->cyl_am, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->cyl_am, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->est_maf, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->est_maf, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->inj_pw, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->inj_pw, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->knock_ct, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->knock_ct, 8u, 0xffu);

    return (8);
}

int rus_efi_can_verbose_base5_unpack(
    struct rus_efi_can_verbose_base5_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->cyl_am = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->cyl_am |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->est_maf = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->est_maf |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->inj_pw = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->inj_pw |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->knock_ct = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->knock_ct |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int rus_efi_can_verbose_base5_init(struct rus_efi_can_verbose_base5_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct rus_efi_can_verbose_base5_t));

    return 0;
}

bool rus_efi_can_verbose_base5_cyl_am_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base5_est_maf_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base5_inj_pw_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base5_knock_ct_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int rus_efi_can_verbose_base6_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base6_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->fuel_used, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->fuel_used, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->fuel_flow, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->fuel_flow, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->fuel_trim1, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->fuel_trim1, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->fuel_trim2, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->fuel_trim2, 8u, 0xffu);

    return (8);
}

int rus_efi_can_verbose_base6_unpack(
    struct rus_efi_can_verbose_base6_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->fuel_used = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->fuel_used |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fuel_flow = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->fuel_flow |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->fuel_trim1 = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->fuel_trim1 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->fuel_trim2 = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->fuel_trim2 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int rus_efi_can_verbose_base6_init(struct rus_efi_can_verbose_base6_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct rus_efi_can_verbose_base6_t));

    return 0;
}

bool rus_efi_can_verbose_base6_fuel_used_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base6_fuel_flow_is_in_range(uint16_t value)
{
    return (value <= 65400u);
}

bool rus_efi_can_verbose_base6_fuel_trim1_is_in_range(uint16_t value)
{
    return (value <= 5000u);
}

bool rus_efi_can_verbose_base6_fuel_trim2_is_in_range(uint16_t value)
{
    return (value <= 5000u);
}

int rus_efi_can_verbose_base7_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base7_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->lam1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->lam1, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->lam2, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->lam2, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->fp_low, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->fp_low, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->fp_high, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->fp_high, 8u, 0xffu);

    return (8);
}

int rus_efi_can_verbose_base7_unpack(
    struct rus_efi_can_verbose_base7_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->lam1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->lam1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->lam2 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->lam2 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->fp_low = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->fp_low |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->fp_high = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->fp_high |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int rus_efi_can_verbose_base7_init(struct rus_efi_can_verbose_base7_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct rus_efi_can_verbose_base7_t));

    return 0;
}

bool rus_efi_can_verbose_base7_lam1_is_in_range(uint16_t value)
{
    return (value <= 20000u);
}

bool rus_efi_can_verbose_base7_lam2_is_in_range(uint16_t value)
{
    return (value <= 20000u);
}

bool rus_efi_can_verbose_base7_fp_low_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

bool rus_efi_can_verbose_base7_fp_high_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int rus_efi_can_verbose_base8_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_base8_t *src_p,
    size_t size)
{
    uint8_t cam1_e;
    uint8_t cam1_etar;
    uint8_t cam1_i;
    uint8_t cam1_itar;
    uint8_t cam2_e;
    uint8_t cam2_etar;
    uint8_t cam2_i;
    uint8_t cam2_itar;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    cam1_i = (uint8_t)src_p->cam1_i;
    dst_p[0] |= pack_left_shift_u8(cam1_i, 0u, 0xffu);
    cam1_itar = (uint8_t)src_p->cam1_itar;
    dst_p[1] |= pack_left_shift_u8(cam1_itar, 0u, 0xffu);
    cam1_e = (uint8_t)src_p->cam1_e;
    dst_p[2] |= pack_left_shift_u8(cam1_e, 0u, 0xffu);
    cam1_etar = (uint8_t)src_p->cam1_etar;
    dst_p[3] |= pack_left_shift_u8(cam1_etar, 0u, 0xffu);
    cam2_i = (uint8_t)src_p->cam2_i;
    dst_p[4] |= pack_left_shift_u8(cam2_i, 0u, 0xffu);
    cam2_itar = (uint8_t)src_p->cam2_itar;
    dst_p[5] |= pack_left_shift_u8(cam2_itar, 0u, 0xffu);
    cam2_e = (uint8_t)src_p->cam2_e;
    dst_p[6] |= pack_left_shift_u8(cam2_e, 0u, 0xffu);
    cam2_etar = (uint8_t)src_p->cam2_etar;
    dst_p[7] |= pack_left_shift_u8(cam2_etar, 0u, 0xffu);

    return (8);
}

int rus_efi_can_verbose_base8_unpack(
    struct rus_efi_can_verbose_base8_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t cam1_e;
    uint8_t cam1_etar;
    uint8_t cam1_i;
    uint8_t cam1_itar;
    uint8_t cam2_e;
    uint8_t cam2_etar;
    uint8_t cam2_i;
    uint8_t cam2_itar;

    if (size < 8u) {
        return (-EINVAL);
    }

    cam1_i = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->cam1_i = (int8_t)cam1_i;
    cam1_itar = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->cam1_itar = (int8_t)cam1_itar;
    cam1_e = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->cam1_e = (int8_t)cam1_e;
    cam1_etar = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->cam1_etar = (int8_t)cam1_etar;
    cam2_i = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->cam2_i = (int8_t)cam2_i;
    cam2_itar = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->cam2_itar = (int8_t)cam2_itar;
    cam2_e = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->cam2_e = (int8_t)cam2_e;
    cam2_etar = unpack_right_shift_u8(src_p[7], 0u, 0xffu);
    dst_p->cam2_etar = (int8_t)cam2_etar;

    return (0);
}

int rus_efi_can_verbose_base8_init(struct rus_efi_can_verbose_base8_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct rus_efi_can_verbose_base8_t));

    return 0;
}

bool rus_efi_can_verbose_base8_cam1_i_is_in_range(int8_t value)
{
    return ((value >= -100) && (value <= 100));
}

bool rus_efi_can_verbose_base8_cam1_itar_is_in_range(int8_t value)
{
    return ((value >= -100) && (value <= 100));
}

bool rus_efi_can_verbose_base8_cam1_e_is_in_range(int8_t value)
{
    return ((value >= -100) && (value <= 100));
}

bool rus_efi_can_verbose_base8_cam1_etar_is_in_range(int8_t value)
{
    return ((value >= -100) && (value <= 100));
}

bool rus_efi_can_verbose_base8_cam2_i_is_in_range(int8_t value)
{
    return ((value >= -100) && (value <= 100));
}

bool rus_efi_can_verbose_base8_cam2_itar_is_in_range(int8_t value)
{
    return ((value >= -100) && (value <= 100));
}

bool rus_efi_can_verbose_base8_cam2_e_is_in_range(int8_t value)
{
    return ((value >= -100) && (value <= 100));
}

bool rus_efi_can_verbose_base8_cam2_etar_is_in_range(int8_t value)
{
    return ((value >= -100) && (value <= 100));
}

int rus_efi_can_verbose_pro0_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_pro0_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->gear_sen, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->sensor_error, 0u, 0x01u);

    return (8);
}

int rus_efi_can_verbose_pro0_unpack(
    struct rus_efi_can_verbose_pro0_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->gear_sen = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->sensor_error = unpack_right_shift_u8(src_p[1], 0u, 0x01u);

    return (0);
}

int rus_efi_can_verbose_pro0_init(struct rus_efi_can_verbose_pro0_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct rus_efi_can_verbose_pro0_t));

    return 0;
}

bool rus_efi_can_verbose_pro0_gear_sen_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

bool rus_efi_can_verbose_pro0_sensor_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int rus_efi_can_verbose_pro1_pack(
    uint8_t *dst_p,
    const struct rus_efi_can_verbose_pro1_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->fw_pressure, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->fw_pressure, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->rw_pressure, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->rw_pressure, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->fw_temp, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->rw_temp, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->fw_batt_v, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->rw_batt_v, 0u, 0xffu);

    return (8);
}

int rus_efi_can_verbose_pro1_unpack(
    struct rus_efi_can_verbose_pro1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->fw_pressure = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->fw_pressure |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->rw_pressure = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->rw_pressure |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->fw_temp = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->rw_temp = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->fw_batt_v = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->rw_batt_v = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int rus_efi_can_verbose_pro1_init(struct rus_efi_can_verbose_pro1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct rus_efi_can_verbose_pro1_t));

    return 0;
}

bool rus_efi_can_verbose_pro1_fw_pressure_is_in_range(uint16_t value)
{
    return (value <= 10000u);
}

bool rus_efi_can_verbose_pro1_rw_pressure_is_in_range(uint16_t value)
{
    return (value <= 10000u);
}

bool rus_efi_can_verbose_pro1_fw_temp_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

bool rus_efi_can_verbose_pro1_rw_temp_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

bool rus_efi_can_verbose_pro1_fw_batt_v_is_in_range(uint8_t value)
{
    return (value <= 40u);
}

bool rus_efi_can_verbose_pro1_rw_batt_v_is_in_range(uint8_t value)
{
    return (value <= 40u);
}
